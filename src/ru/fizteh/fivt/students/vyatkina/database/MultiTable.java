package ru.fizteh.fivt.students.vyatkina.database;

import ru.fizteh.fivt.storage.strings.Table;
import ru.fizteh.fivt.students.vyatkina.database.Diff;
import ru.fizteh.fivt.students.vyatkina.database.MultiTableProvider;

import java.io.IOException;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class MultiTable implements Table {

    private MultiTableProvider tableProvider;
    protected Map<String, Diff<String>> values;
    private final String name;

    public static final String KEY_SHOULD_NOT_BE_NULL = "Key should not be null";
    public static final String VALUE_SHOULD_NOT_BE_NULL = "Value should not be null";
    public static final String KEY_SHOULD_NOT_BE_EMPTY = "Key should not be empty";
    public static final String VALUE_SHOULD_NOT_BE_EMPTY = "Value should not be empty";

    public MultiTable (String name, Map<String, Diff<String>> values, MultiTableProvider tableProvider) {
        this.name = name;
        this.values = values;
        this.tableProvider = tableProvider;
    }

    void keyValidCheck (String key) {
        if (key == null) {
            throw new IllegalArgumentException (KEY_SHOULD_NOT_BE_NULL);
        }
        if (key.trim ().isEmpty ()) {
            throw new IllegalArgumentException (KEY_SHOULD_NOT_BE_EMPTY);
        }
    }

    void valueValidCheck (String value) {
        if (value == null) {
            throw new IllegalArgumentException (VALUE_SHOULD_NOT_BE_NULL);
        }
        if (value.trim ().isEmpty ()) {
            throw new IllegalArgumentException (VALUE_SHOULD_NOT_BE_EMPTY);
        }
    }

    @Override
    public String getName () {
        return name;
    }

    @Override
    public String get (String key) {

        keyValidCheck (key);

        Diff<String> diff = values.get (key);
        String value = null;
        if (diff != null) {
            value = diff.getValue ();
        }

        return value;
    }

    @Override
    public String put (String key, String value) {

        keyValidCheck (key);
        valueValidCheck (value);

        Diff<String> oldValue = values.get (key);
        String oldStringValue;

        if (oldValue == null) {
            values.put (key, new Diff (null, value));
            oldStringValue = null;

        } else {
            oldStringValue = oldValue.getValue ();
            oldValue.setValue (value);
        }

        return oldStringValue;
    }

    @Override
    public String remove (String key) {

        keyValidCheck (key);

        Diff<String> oldValue = values.get (key);
        String oldStringValue;

        if (oldValue == null) {
            oldStringValue = null;

        } else {
            oldStringValue = oldValue.getValue ();
            oldValue.setValue (null);
        }

        return oldStringValue;
    }

    @Override
    public int commit ()  {
        int commited = 0;
        try {
            tableProvider.writeTableOnDisk (this);
            for (String key : values.keySet ()) {
                Diff<String> diff = values.get (key);
                if (diff.isNeedToCommit ()) {
                    diff.changeAsIfCommited ();
                    ++commited;
                }
            }
        }
        catch (IOException e) {
            throw new WrappedIOException (e.getMessage ());
        }
        return commited;
    }

    @Override
    public int size () {
        int realSize = 0;
        for (Diff diff : values.values ()) {
            if (diff.getValue () != null) {
                ++realSize;
            }
        }
        return realSize;
    }

    @Override
    public int rollback () {
        int changes = 0;
        Set<String> keys = values.keySet ();
        for (String key : keys) {
            Diff<String> diff = values.get (key);
            if (diff.isNeedToCommit ()) {
                ++changes;
                diff.setValue (diff.getCommitedValue ());
            }
        }
        return changes;
    }

    public Set<String> getKeys () {
        return values.keySet ();
    }

    public Set<String> getKeysThatValuesHaveChanged () {
        Set<String> keysThatValuesHaveChanged = new HashSet<> ();
        for (String key : values.keySet ()) {
            if (values.get (key).isNeedToCommit ()) {
                keysThatValuesHaveChanged.add (key);
            }
        }
        return keysThatValuesHaveChanged;
    }

    public void putValueFromDisk (String key, String value) {
        values.put (key, new Diff (value, value));
    }

    public int unsavedChanges () {
        int unsavedChanges = 0;
        for (String key : values.keySet ()) {
            if (values.get (key).isNeedToCommit ()) {
                ++unsavedChanges;
            }
        }
        return unsavedChanges;
    }

}
